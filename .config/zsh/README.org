#+TITLE: ZSH configuration
#+PROPERTY: header-args:mkdirp yes

* Introduction

Hello and welcome. This is the Org-file which contains (or will contain) all of
my personal zsh configurations. There's a lot to go through, but hopefully
writing this will give me a good excuse to make an end of it all.

I'm presently not ready for fully committing to using emacs' built-in shell
=eshell=, so that means relying on =zsh=.

* .zshrc
** User edit warning
First we tell vim to use plain 'sh' highlighting:
#+begin_src shell :tangle ~/.config/zsh/.zshrc
  # vim: set ft=sh :
#+end_src
And tell the user not to edit this file:
#+begin_src shell :tangle ~/.config/zsh/.zshrc
  # Don't edit this file. Modify and re-tangle the README.org instead.
  # (it may or may not do this when you write it)
#+end_src
** Startup-chain logic
Next exit if this is a non-interactive shell.
#+begin_src shell :tangle ~/.config/zsh/.zshrc
  [[ $- != *i* ]] && return
#+end_src
Launch a graphical environment: sway on tty7, Xorg on tty5, and nothing for
other terminals.
#+begin_src shell :tangle ~/.config/zsh/.zshrc
  case "${TTY}" in
      /dev/tty5)
          startx $XINITRC ;;
      /dev/tty7)
          exec sway ;;
      ,*)
      ;;
  esac
#+end_src
Start =tmux= conditionally. Only if the host terminal isn't on our whitelist,
and there isn't already a tmux running. We note the current $TERM and carry it
over to the resulting tmux session. My neofetch config also displays this value
if set.
#+begin_src shell :tangle ~/.config/zsh/.zshrc
  case "${TMUX}" in
      ,*) export OLDTERM="${TERM}"
         ;;
      "") case "${TERM}" in
              alacritty|eterm*|xterm-*) ;;
              ,*) OLDTERM="${TERM}" exec tmux ;;
          esac ;;
  esac
#+end_src
** zplug, for plugins
Bootstrap and invoke zplug, a git-based /zsh/ plugin manager similar to vim-plug.
#+begin_src shell :tangle ~/.config/zsh/.zshrc
  # Maybe install zplug, and definitely make it update stuff
  export ZDOTDIR="$XDG_CONFIG_HOME/zsh"
  export ZPLUG_HOME="$ZDOTDIR/zplug"
  [ -d $ZDOTDIR/zplug ] || (
      git clone https://github.com/zplug/zplug $ZPLUG_HOME #2>/dev/null
  )
  source $ZPLUG_HOME/init.zsh
  zplug 'zplug/zplug', hook-build:'zplug --self-manage'
  zplug "romkatv/powerlevel10k", as:theme, depth:1
  zplug "zdharma-continuum/fast-syntax-highlighting", defer:2
  # zplug 'zsh-users/zsh-history-substring-search', depth:1
  zplug 'zsh-users/zsh-autosuggestions'
  zplug 'zsh-users/zsh-completions'
  zplug "dylanaraps/neofetch", as:command, depth:1
  zplug "dylanaraps/pfetch", as:command, depth:1
  zplug "keroserene/rickrollrc", as:command, depth:1, use:roll.sh, rename-to:dc
  zplug "hkbakke/bash-insulter", use:"src/*"
  # Install plugins if there are plugins that have not been installed
  zplug check --verbose || (
      printf "Install? [y/N]: "
      if read -q; then
          echo; zplug install
      fi
  )
#+end_src
** load =zplug= statements
Finally, load those zplugs:
#+begin_src shell :tangle ~/.config/zsh/.zshrc
  zplug load
#+end_src
** Display pretty text graphics
Now that all the possibilities for launching other environments or interactive
prompts have been exhausted, we can do the thing. The thing that makes opening
new terminals fun and exciting.
#+begin_src shell :tangle ~/.config/zsh/.zshrc
  (( $COLUMNS <= 84 )) && FETCH='pfetch' || FETCH='neofetch'
  $FETCH #--ascii_colors 4 --colors 7 4 4 4 4 7
#+end_src
** set options and appease wizards
The following was originally added automatically by PowerLevel10k's setup
wizard. P10K is the prompt I use and is clean, extensible, and feature-rich.
(keep the comments so it doesn't regenerate)
#+begin_src shell :tangle ~/.config/zsh/.zshrc
  # Enable Powerlevel10k instant prompt. Should stay close to the top of
  # ~/.config/zsh/.zshrc. Initialization code that may require console input
  # (password prompts, [y/n] confirmations, etc.) must go above this block;
  # everything else may go below.
  if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
      source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
  fi
#+end_src
The following is currently disabled, but comes from Luke Smith's config. If I
used the tty more I might re-enable it.
#+begin_src shell :tangle ~/.config/zsh/.zshrc
  # Switch escape and caps if tty and no passwd required:
  # sudo -n loadkeys ~/.local/share/ttymaps.kmap 2>/dev/null
#+end_src
And now for some boilerplate-ish settings that various zsh setup wizards apply
on first run (Keep the comments so they don't regenerate):
#+begin_src shell :tangle ~/.config/zsh/.zshrc
  # Lines configured by zsh-newuser-install
  HISTFILE=~/.local/share/zsh/histfile
  HISTSIZE=1000
  SAVEHIST=1000
  setopt extendedglob nomatch
  setopt HIST_IGNORE_ALL_DUPS
  unsetopt autocd beep
  # End of lines configured by zsh-newuser-install
  # The following lines were added by compinstall
  zstyle :compinstall filename "$ZDOTDIR/~/.config/zsh/.zshrc"
  autoload -Uz compinit
  # Basic auto/tab complete
  zstyle ':completion:*' menu select
  zmodload zsh/complist
  _comp_options+=(globdots) # Include hidden files.
  compinit
  # End of lines added by compinstall
#+end_src
And finally, load the cache file for powerlevel10k if it exists.
#+begin_src shell :tangle ~/.config/zsh/.zshrc
  # To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
  [[ ! -f $ZDOTDIR/.p10k.zsh ]] || source $ZDOTDIR/.p10k.zsh
#+end_src
Next we source some external settings files I wrote to keep the
~/.config/zsh/.zshrc clean:
#+begin_src shell :tangle ~/.config/zsh/.zshrc
  # source aliases and functions files
  source $ZDOTDIR/aliases.zsh
  source $ZDOTDIR/functions.zsh
  # source $ZDOTDIR/insulter.zsh
#+end_src
** vi is pretty cool
Since the emacs terminal is bad, let's rely on zsh itself for vi emulation (it
actually does a pretty decent job and even has a visual mode like vim):
#+begin_src shell :tangle ~/.config/zsh/.zshrc
  # Use vim keys in tab complete menu etc:
  bindkey -M menuselect 'h' vi-backward-char
  bindkey -M menuselect 'k' vi-up-line-or-history
  bindkey -M menuselect 'l' vi-forward-char
  bindkey -M menuselect 'j' vi-down-line-or-history
  bindkey -v "^?" backward-delete-char
  autoload edit-command-line; zle -N edit-command-line
  bindkey '^v' edit-command-line

  autoload -Uz up-line-or-beginning-search down-line-or-beginning-search
  zle -N up-line-or-beginning-search
  zle -N down-line-or-beginning-search
  bindkey '^[[A' up-line-or-beginning-search
  bindkey '^[[B' down-line-or-beginning-search
  bindkey -M vicmd 'k' up-line-or-beginning-search
  bindkey -M vicmd 'j' down-line-or-beginning-search
#+end_src
The following is copied more-or-less from Luke Smith's~/.config/zsh/.zshrc. I
have, however, done a bit of syntax policing and line-shuffling. What this
actually does is enable nvim-style terminal cursor-shape changes on changing
zsh's built-in vi modes. insert is a bar, normal and visual are blocks, replace
is an underscore. This is a killer feature. Once you use it you will not be able
to live without it.
#+begin_src shell :tangle ~/.config/zsh/.zshrc
  #############################################################
  ######   Luke Smith's custom vi-mode cursor switcher   ######
  #############################################################
  zle-keymap-select() {
      if [[ ${KEYMAP} == vicmd ]] || [[ $1 = 'block' ]];
      then echo -ne '\e[1 q'
      elif [[ ${KEYMAP} == main ]] ||
               [[ ${KEYMAP} == viins ]] ||
               [[ ${KEYMAP} = '' ]] ||
               [[ $1 = 'beam' ]];
      then echo -ne '\e[5 q'
      fi
  }
  zle-line-init() {
      zle -K viins # initiate `vi insert` as keymap (can be removed
      # if `bindkey -V` has been set elsewhere)
      echo -ne "\e[5 q"
  }
  zle -N zle-keymap-select
  zle -N zle-line-init
  echo -ne '\e[5 q' # Use beam shape cursor on startup.
  preexec() { echo -ne '\e[5 q' ;} # Use beam shape cursor for each new prompt.
  #############################################################
  ###### End Luke Smith's custom vi-mode cursor switcher ######
  #############################################################
#+end_src
And that's actually it for the ~/.config/zsh/.zshrc.

* aliases.zsh
** User edit warning
Point readers back to this source file:
#+begin_src shell :tangle ~/.config/zsh/aliases.zsh
  # Don't edit this file. Edit the README.org instead, and tangle it.
#+end_src
** Rust coreutil-replacement aliases, now with fallback
#+begin_src shell :tangle ~/.config/zsh/aliases.zsh
  #which doas >/dev/null && alias sudo='doas'
  which exa >/dev/null && alias ls='exa'
  which exa >/dev/null && alias tree='exa -T'
  which rg >/dev/null && alias grep='rg -uuu'
  #which dotacat >/dev/null && alias lolcat='dotacat'
#+end_src
** color or auto-sudo, but not giving you up
#+begin_src shell :tangle ~/.config/zsh/aliases.zsh
  # [ -f /usr/bin/paru ] && alias pacman="paru" || alias pacman="sudo pacman"
  alias cd..="cd .."
  alias spider="spider -s 2 -c"
  alias mounr="doas mount"
  alias umounr="doas umount -r"
  # alias dc="curl -s -L https://raw.githubusercontent.com/keroserene/rickrollrc/master/roll.sh | bash"
  alias ping="ping -c 4"
  alias ip="ip -c"
#+end_src
* functions.zsh
** Tmux clean function to kill detached sessions
#+begin_src shell :tangle ~/.config/zsh/functions.zsh
  tmux-clean() {
      sessions=$(tmux ls |
                     grep -v attached |
                     sed 's/\:\s.*$//'
              )
      for session in $sessions
      do
          tmux kill-session -t $session
      done
  }
#+end_src
** clear() is broken in tmux, so redefine it
#+begin_src shell :tangle ~/.config/zsh/functions.zsh
  [ -n "${TMUX}" ] && (
      clear=$(which clear)
      clear() {
          $clear &&
              tmux clear-history &&
              $clear
      }
  )
#+end_src
** Tell vim to highlight the file as sh
(their zsh highlighting is ugly.)
#+begin_src shell :tangle ~/.config/zsh/functions.zsh
  # vim: set ft=sh :
#+end_src
